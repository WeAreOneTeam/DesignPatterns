#Decorator（装饰模式）

##定义
装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。

动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活。

##设计初衷
通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的。

##要点
装饰者与被装饰者拥有共同的超类，继承的目的是继承类型，而不是行为。
实际上Java 的I/O API就是使用Decorator实现的。

##形象的比喻
Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？

##程序说明
Human： 接口，包含wearClothes()和walkToWhere()两个方法声明

Person：继承接口Human, 并实现函数wearClothes()和walkToWhere()，作为一切的基础

Decorator：继承接口Human, 并将wearClothes()和walkToWhere()封装进自己的同名函数中

Decorator0, Decorator1, Decorator2：分别继承类Decorator, Decorator0, Decorator1, 重写基类的wearClothes()和walkToWhere()方法，并在其中加入额外处理
